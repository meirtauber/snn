#!/usr/bin/env python

# Copyright (c) 2018 Intel Labs.
# authors: German Ros (german.ros@intel.com)
#
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.

"""
This module contains a local planner to perform low-level waypoint following based on PID controllers.
"""

from enum import Enum
from collections import deque
import random
import math

import numpy as np

import carla


def get_speed(vehicle):
    """
    Compute speed of a vehicle in Km/h.
    :param vehicle: the vehicle for which speed is calculated
    :return: speed as a float in Km/h
    """
    vel = vehicle.get_velocity()
    return 3.6 * math.sqrt(vel.x**2 + vel.y**2 + vel.z**2)


def is_within_distance(target_transform, current_transform, max_distance):
    """
    Check if a target transform is within a certain distance from a current transform.
    :param target_transform: location of the target object
    :param current_transform: location of the reference object
    :param max_distance: maximum allowed distance
    :return: True if target transform is within max_distance from current transform
    """
    dist = current_transform.location.distance(target_transform.location)
    return dist < max_distance


def get_trafficlight_trigger_location(traffic_light):
    """
    Calculates the trigger location for a given traffic light.
    """

    def rotate_point(point, angle):
        """
        rotate a given point by a given angle
        """
        x_ = (
            math.cos(math.radians(angle)) * point.x
            - math.sin(math.radians(angle)) * point.y
        )
        y_ = (
            math.sin(math.radians(angle)) * point.x
            + math.cos(math.radians(angle)) * point.y
        )
        return carla.Vector3D(x_, y_, point.z)

    base_transform = traffic_light.get_transform()
    base_rot = base_transform.rotation.yaw
    area_loc = base_transform.transform(traffic_light.trigger_volume.location)

    # Discretize the trigger box into points
    area_ext = traffic_light.trigger_volume.extent
    x_values = np.arange(-area_ext.x, area_ext.x, 1)
    y_values = np.arange(-area_ext.y, area_ext.y, 1)

    for x in x_values:
        for y in y_values:
            point = rotate_point(carla.Vector3D(x, y, 0), base_rot)
            point_location = area_loc + carla.Location(x=point.x, y=point.y)

            if traffic_light.get_world().get_map().get_waypoint(point_location):
                return point_location

    return None


class RoadOption(Enum):
    """
    RoadOption represents the possible topological configurations when moving from a segment of lane to other.
    """

    VOID = -1
    LEFT = 1
    RIGHT = 2
    STRAIGHT = 3
    LANEFOLLOW = 4
    CHANGELANELEFT = 5
    CHANGELANERIGHT = 6


class LocalPlanner(object):
    """
    LocalPlanner implements the basic behavior of following a trajectory of waypoints that is generated by a
    global planner. The low-level motion of the vehicle is computed by using two PID controllers, one is used
    for the lateral control and the other for the longitudinal control (throttle and brake).
    When multiple paths are available (intersections) this local planner makes a random choice.
    """

    # minimum distance to target waypoint as a percentage of the total distance from last waypoint
    MIN_DISTANCE_PERCENTAGE = 0.9

    def __init__(self, vehicle, opt_dict=None):
        """
        :param vehicle: actor to apply to local planner logic onto
        :param opt_dict: dictionary in case some of its parameters want to be overridden.
            This includes:
                'dt' (float): time between simulation ticks
                'target_speed' (float): desired speed in Km/h
                'sampling_radius' (float): distance from the waypoint to the center of the lane
                'lateral_control_dict' (dict): values of the lateral PID controller
                'longitudinal_control_dict' (dict): values of the longitudinal PID controller
        """
        self._vehicle = vehicle
        self._world = self._vehicle.get_world()
        self._map = self._world.get_map()

        self._dt = None
        self._target_speed = 20.0  # Km/h
        self._sampling_radius = 2.0
        self._min_proximity_threshold = 10.0  # meters
        self._args_lateral_dict = {"K_P": 1.95, "K_I": 0.05, "K_D": 0.2}
        self._args_longitudinal_dict = {"K_P": 1.0, "K_I": 0.05, "K_D": 0}

        self._vehicle_controller = None
        self.target_waypoint = None
        self.target_road_option = None
        self.incoming_waypoint = None
        self.incoming_road_option = None

        self._waypoints_queue = deque(maxlen=20000)
        self._waypoint_buffer = deque(maxlen=20)
        self._min_waypoint_queue_length = 200

        # initializing controller
        self._init_controller(opt_dict)

    def _init_controller(self, opt_dict):
        """
        Controller initialization.
        :param opt_dict: dictionary of arguments.
        """
        # default params
        self._dt = 1.0 / 20.0
        self._target_speed = 20.0  # Km/h
        self._sampling_radius = self._target_speed * 1 / 3.6  # 1 seconds horizon
        self._min_proximity_threshold = 10.0  # meters
        self._args_lateral_dict = {"K_P": 1.95, "K_I": 0.05, "K_D": 0.2}
        self._args_longitudinal_dict = {"K_P": 1.0, "K_I": 0.05, "K_D": 0}

        # parameters overload
        if opt_dict:
            if "dt" in opt_dict:
                self._dt = opt_dict["dt"]
            if "target_speed" in opt_dict:
                self._target_speed = opt_dict["target_speed"]
            if "sampling_radius" in opt_dict:
                self._sampling_radius = (
                    self._target_speed * opt_dict["sampling_radius"] / 3.6
                )
            if "lateral_control_dict" in opt_dict:
                self._args_lateral_dict = opt_dict["lateral_control_dict"]
            if "longitudinal_control_dict" in opt_dict:
                self._args_longitudinal_dict = opt_dict["longitudinal_control_dict"]
            if "min_proximity_threshold" in opt_dict:
                self._min_proximity_threshold = opt_dict["min_proximity_threshold"]

        self._vehicle_controller = VehiclePIDController(
            self._vehicle,
            args_lateral=self._args_lateral_dict,
            args_longitudinal=self._args_longitudinal_dict,
        )

    def set_speed(self, speed):
        """
        Changes the target speed.
        :param speed: new target speed in Km/h
        """
        self._target_speed = speed

    def set_global_plan(self, current_plan, stop_at_last_waypoint=True):
        """
        Adds a new global plan to the planner.
        The purpose of this function is to update the list of waypoints that the local planner
        should follow at run time.
        :param current_plan: list of waypoints from the global planner
        :param stop_at_last_waypoint: whether to stop at the last waypoint
        """
        self._waypoints_queue.clear()
        for elem in current_plan:
            self._waypoints_queue.append(elem)

        if stop_at_last_waypoint and len(self._waypoints_queue) > 1:
            # remove last waypoint to avoid stopping at destination
            self._waypoints_queue.pop()

    def get_incoming_waypoint_and_direction(self, steps=5):
        """
        Returns direction and waypoint at a distance ahead.
        :param steps: number of steps to look ahead
        :return: (waypoint, road_option)
        """
        if len(self._waypoints_queue) > steps:
            return self._waypoints_queue[steps]

        else:
            try:
                wpt, direction = self._waypoints_queue[-1]
                return wpt, direction
            except IndexError as e:
                print(e)
                return None, RoadOption.VOID

    def run_step(self, debug=False):
        """
        Execute one step of local planning which involves running the longitudinal and lateral PID controllers to
        follow the waypoints trajectory.
        :param debug: boolean flag to activate waypoints debugging
        :return: control to be applied
        """

        # not enough waypoints in the horizon? => add more!
        if len(self._waypoints_queue) < self._min_waypoint_queue_length:
            return None

        if len(self._waypoints_queue) == 0:
            control = carla.VehicleControl()
            control.steer = 0.0
            control.throttle = 0.0
            control.brake = 1.0
            control.hand_brake = False
            control.manual_gear_shift = False
            return control

        # buffering waypoints
        if not self._waypoint_buffer:
            for i in range(20):
                if self._waypoints_queue:
                    self._waypoint_buffer.append(self._waypoints_queue.popleft())
                else:
                    break

        # current vehicle waypoint
        vehicle_transform = self._vehicle.get_transform()
        current_waypoint = self._map.get_waypoint(vehicle_transform.location)

        # get target waypoint
        self.target_waypoint, self.target_road_option = self._waypoint_buffer[0]

        # get incoming waypoint
        self.incoming_waypoint, self.incoming_road_option = (
            self.get_incoming_waypoint_and_direction(steps=5)
        )

        # move using PID controllers
        control = self._vehicle_controller.run_step(
            self._target_speed, self.target_waypoint
        )

        # purge the queue of obsolete waypoints
        max_index = -1
        for i, (waypoint, _) in enumerate(self._waypoint_buffer):
            if is_within_distance(
                waypoint.transform.location, self._vehicle.get_location(), 2.0
            ):
                max_index = i
        if max_index >= 0:
            for i in range(max_index + 1):
                self._waypoint_buffer.popleft()

        if debug:
            draw_waypoints(self._world, [self.target_waypoint], z=0.5)

        return control

    def done(self):
        """
        Returns whether the planner has reached the destination.
        :return: boolean
        """
        return len(self._waypoints_queue) == 0 and len(self._waypoint_buffer) == 0


class VehiclePIDController:
    """
    VehiclePIDController is the combination of two PID controllers (lateral and longitudinal) to perform the
    low level control a vehicle from client side
    """

    def __init__(
        self,
        vehicle,
        args_lateral,
        args_longitudinal,
        max_throttle=0.75,
        max_brake=0.3,
        max_steering=0.8,
    ):
        """
        :param vehicle: actor to apply to local planner logic onto
        :param args_lateral: dictionary of arguments to set the lateral PID controller
        :param args_longitudinal: dictionary of arguments to set the longitudinal PID controller
        """
        self.max_brake = max_brake
        self.max_throttle = max_throttle
        self.max_steering = max_steering

        self._vehicle = vehicle
        self._world = self._vehicle.get_world()
        self._lon_controller = PIDLongitudinalController(
            self._vehicle, **args_longitudinal
        )
        self._lat_controller = PIDLateralController(self._vehicle, **args_lateral)

    def run_step(self, target_speed, waypoint):
        """
        Execute one step of control invoking both lateral and longitudinal PID controllers to reach a target waypoint
        at a given target speed.
        :param target_speed: desired vehicle speed
        :param waypoint: target location encoded as a waypoint
        :return: control to be applied
        """
        acceleration = self._lon_controller.run_step(target_speed)
        current_steering = self._lat_controller.run_step(waypoint)
        control = carla.VehicleControl()
        if acceleration >= 0.0:
            control.throttle = min(abs(acceleration), self.max_throttle)
            control.brake = 0.0
        else:
            control.throttle = 0.0
            control.brake = min(abs(acceleration), self.max_brake)

        if current_steering > 0.99:
            current_steering = 0.99
        if current_steering < -0.99:
            current_steering = -0.99

        control.steer = current_steering
        control.hand_brake = False
        control.manual_gear_shift = False
        return control


class PIDLongitudinalController:
    """
    PIDLongitudinalController implements longitudinal control using a PID.
    """

    def __init__(self, vehicle, K_P=1.0, K_I=0.0, K_D=0.0, dt=0.03):
        """
        :param vehicle: actor to apply to local planner logic onto
        :param K_P: Proportional term
        :param K_I: Integral term
        :param K_D: Differential term
        :param dt: time differential in seconds
        """
        self._vehicle = vehicle
        self._K_P = K_P
        self._K_I = K_I
        self._K_D = K_D
        self._dt = dt
        self._error_buffer = deque(maxlen=10)

    def run_step(self, target_speed, debug=False):
        """
        Execute one step of longitudinal control to reach a given target speed.
        :param target_speed: target speed in Km/h
        :return: acceleration control value
        """
        current_speed = get_speed(self._vehicle)
        return self._pid_control(target_speed, current_speed)

    def _pid_control(self, target_speed, current_speed):
        """
        Estimate the throttle/brake of the vehicle based on the PID equations
        :param target_speed:  target speed in Km/h
        :param current_speed: current speed of the vehicle in Km/h
        :return: throttle/brake control value
        """
        error = target_speed - current_speed
        self._error_buffer.append(error)

        if len(self._error_buffer) >= 2:
            _de = (self._error_buffer[-1] - self._error_buffer[-2]) / self._dt
            _ie = sum(self._error_buffer) * self._dt
        else:
            _de = 0.0
            _ie = 0.0

        return np.clip(
            (self._K_P * error) + (self._K_D * _de) + (self._K_I * _ie), -1.0, 1.0
        )


class PIDLateralController:
    """
    PIDLateralController implements lateral control using a PID.
    """

    def __init__(self, vehicle, K_P=1.0, K_I=0.0, K_D=0.0, dt=0.03):
        """
        :param vehicle: actor to apply to local planner logic onto
        :param K_P: Proportional term
        :param K_I: Integral term
        :param K_D: Differential term
        :param dt: time differential in seconds
        """
        self._vehicle = vehicle
        self._K_P = K_P
        self._K_I = K_I
        self._K_D = K_D
        self._dt = dt
        self._e_buffer = deque(maxlen=10)

    def run_step(self, waypoint):
        """
        Execute one step of lateral control to follow a given waypoint path.
        :param waypoint: target waypoint
        :return: steering control in the range [-1, 1] where:
            -1 represent maximum steering to left
            +1 maximum steering to right
        """
        return self._pid_control(waypoint, self._vehicle.get_transform())

    def _pid_control(self, waypoint, vehicle_transform):
        """
        Estimate the steering angle of the vehicle based on the PID equations
        :param waypoint: target waypoint
        :param vehicle_transform: current transform of the vehicle
        :return: steering control in the range [-1, 1]
        """
        v_begin = vehicle_transform.location
        v_end = v_begin + carla.Location(
            x=math.cos(math.radians(vehicle_transform.rotation.yaw)),
            y=math.sin(math.radians(vehicle_transform.rotation.yaw)),
        )

        v_vec = np.array([v_end.x - v_begin.x, v_end.y - v_begin.y, 0.0])
        w_vec = np.array(
            [
                waypoint.transform.location.x - v_begin.x,
                waypoint.transform.location.y - v_begin.y,
                0.0,
            ]
        )
        _dot = math.acos(
            np.clip(
                np.dot(w_vec, v_vec) / (np.linalg.norm(w_vec) * np.linalg.norm(v_vec)),
                -1.0,
                1.0,
            )
        )

        _cross = np.cross(v_vec, w_vec)
        if _cross[2] < 0:
            _dot *= -1.0

        self._e_buffer.append(_dot)
        if len(self._e_buffer) >= 2:
            _de = (self._e_buffer[-1] - self._e_buffer[-2]) / self._dt
            _ie = sum(self._e_buffer) * self._dt
        else:
            _de = 0.0
            _ie = 0.0

        return np.clip(
            (self._K_P * _dot) + (self._K_I * _ie) + (self._K_D * _de), -1.0, 1.0
        )
